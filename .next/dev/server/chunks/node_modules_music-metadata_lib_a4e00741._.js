module.exports = [
"[project]/node_modules/music-metadata/lib/id3v2/FrameParser.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FrameParser",
    ()=>FrameParser,
    "Id3v2ContentError",
    ()=>Id3v2ContentError,
    "parseGenre",
    ()=>parseGenre
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/token-types/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/common/Util.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/id3v2/ID3v2Token.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v1$2f$ID3v1Parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/id3v1/ID3v1Parser.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$ParseError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/ParseError.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])('music-metadata:id3v2:frame-parser');
const defaultEnc = 'latin1'; // latin1 == iso-8859-1;
function parseGenre(origVal) {
    // match everything inside parentheses
    const genres = [];
    let code;
    let word = '';
    for (const c of origVal){
        if (typeof code === 'string') {
            if (c === '(' && code === '') {
                word += '(';
                code = undefined;
            } else if (c === ')') {
                if (word !== '') {
                    genres.push(word);
                    word = '';
                }
                const genre = parseGenreCode(code);
                if (genre) {
                    genres.push(genre);
                }
                code = undefined;
            } else code += c;
        } else if (c === '(') {
            code = '';
        } else {
            word += c;
        }
    }
    if (word) {
        if (genres.length === 0 && word.match(/^\d*$/)) {
            word = parseGenreCode(word);
        }
        if (word) {
            genres.push(word);
        }
    }
    return genres;
}
function parseGenreCode(code) {
    if (code === 'RX') return 'Remix';
    if (code === 'CR') return 'Cover';
    if (code.match(/^\d*$/)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v1$2f$ID3v1Parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Genres"][Number.parseInt(code, 10)];
    }
}
class FrameParser {
    /**
     * Create id3v2 frame parser
     * @param major - Major version, e.g. (4) for  id3v2.4
     * @param warningCollector - Used to collect decode issue
     */ constructor(major, warningCollector){
        this.major = major;
        this.warningCollector = warningCollector;
    }
    readData(uint8Array, type, includeCovers) {
        if (uint8Array.length === 0) {
            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);
            return;
        }
        const { encoding, bom } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TextEncodingToken"].get(uint8Array, 0);
        const length = uint8Array.length;
        let offset = 0;
        let output = []; // ToDo
        const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);
        let fzero;
        debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);
        switch(type !== 'TXXX' && type[0] === 'T' ? 'T*' : type){
            case 'T*':
            case 'GRP1':
            case 'IPLS':
            case 'MVIN':
            case 'MVNM':
            case 'PCS':
            case 'PCST':
                {
                    let text;
                    try {
                        text = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(1), encoding).replace(/\x00+$/, '');
                    } catch (error) {
                        if (error instanceof Error) {
                            this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);
                            break;
                        }
                        throw error;
                    }
                    switch(type){
                        case 'TMCL':
                        case 'TIPL':
                        case 'IPLS':
                            output = FrameParser.functionList(this.splitValue(type, text));
                            break;
                        case 'TRK':
                        case 'TRCK':
                        case 'TPOS':
                            output = text;
                            break;
                        case 'TCOM':
                        case 'TEXT':
                        case 'TOLY':
                        case 'TOPE':
                        case 'TPE1':
                        case 'TSRC':
                            // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
                            output = this.splitValue(type, text);
                            break;
                        case 'TCO':
                        case 'TCON':
                            output = this.splitValue(type, text).map((v)=>parseGenre(v)).reduce((acc, val)=>acc.concat(val), []);
                            break;
                        case 'PCS':
                        case 'PCST':
                            // TODO: Why `default` not results `1` but `''`?
                            output = this.major >= 4 ? this.splitValue(type, text) : [
                                text
                            ];
                            output = Array.isArray(output) && output[0] === '' ? 1 : 0;
                            break;
                        default:
                            output = this.major >= 4 ? this.splitValue(type, text) : [
                                text
                            ];
                    }
                    break;
                }
            case 'TXXX':
                {
                    const idAndData = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);
                    const textTag = {
                        description: idAndData.id,
                        text: this.splitValue(type, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](idAndData.data, encoding).replace(/\x00+$/, ''))
                    };
                    output = textTag;
                    break;
                }
            case 'PIC':
            case 'APIC':
                if (includeCovers) {
                    const pic = {};
                    offset += 1;
                    switch(this.major){
                        case 2:
                            pic.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset, offset + 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;
                            offset += 3;
                            break;
                        case 3:
                        case 4:
                            fzero = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset, length, defaultEnc);
                            pic.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset, fzero), defaultEnc);
                            offset = fzero + 1;
                            break;
                        default:
                            throw makeUnexpectedMajorVersionError(this.major);
                    }
                    pic.format = FrameParser.fixPictureMimeType(pic.format);
                    pic.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AttachedPictureType"][uint8Array[offset]];
                    offset += 1;
                    fzero = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset, length, encoding);
                    pic.description = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset, fzero), encoding);
                    offset = fzero + nullTerminatorLength;
                    pic.data = uint8Array.subarray(offset, length);
                    output = pic;
                }
                break;
            case 'CNT':
            case 'PCNT':
                output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeUintBE"])(uint8Array);
                break;
            case 'SYLT':
                {
                    const syltHeader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SyncTextHeader"].get(uint8Array, 0);
                    offset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SyncTextHeader"].len;
                    const result = {
                        descriptor: '',
                        language: syltHeader.language,
                        contentType: syltHeader.contentType,
                        timeStampFormat: syltHeader.timeStampFormat,
                        syncText: []
                    };
                    let readSyllables = false;
                    while(offset < length){
                        const nullStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), syltHeader.encoding);
                        offset += nullStr.len;
                        if (readSyllables) {
                            const timestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_BE"].get(uint8Array, offset);
                            offset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_BE"].len;
                            result.syncText.push({
                                text: nullStr.text,
                                timestamp
                            });
                        } else {
                            result.descriptor = nullStr.text;
                            readSyllables = true;
                        }
                    }
                    output = result;
                    break;
                }
            case 'ULT':
            case 'USLT':
            case 'COM':
            case 'COMM':
                {
                    const textHeader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TextHeader"].get(uint8Array, offset);
                    offset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TextHeader"].len;
                    const descriptorStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
                    offset += descriptorStr.len;
                    const textStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
                    const comment = {
                        language: textHeader.language,
                        descriptor: descriptorStr.text,
                        text: textStr.text
                    };
                    output = comment;
                    break;
                }
            case 'UFID':
                {
                    const ufid = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
                    output = {
                        owner_identifier: ufid.id,
                        identifier: ufid.data
                    };
                    break;
                }
            case 'PRIV':
                {
                    const priv = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
                    output = {
                        owner_identifier: priv.id,
                        data: priv.data
                    };
                    break;
                }
            case 'POPM':
                {
                    fzero = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset, length, defaultEnc);
                    const email = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset, fzero), defaultEnc);
                    offset = fzero + 1;
                    const valueLen = length - offset - 1;
                    output = {
                        email,
                        rating: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT8"].get(uint8Array, offset),
                        counter: valueLen > 0 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeUintBE"](uint8Array.subarray(offset + 1)) : undefined
                    };
                    break;
                }
            case 'GEOB':
                {
                    fzero = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset + 1, length, encoding);
                    const mimeType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset + 1, fzero), defaultEnc);
                    offset = fzero + 1;
                    fzero = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset, length, encoding);
                    const filename = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset, fzero), defaultEnc);
                    offset = fzero + 1;
                    fzero = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset, length, encoding);
                    const description = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset, fzero), defaultEnc);
                    offset = fzero + 1;
                    const geob = {
                        type: mimeType,
                        filename,
                        description,
                        data: uint8Array.subarray(offset, length)
                    };
                    output = geob;
                    break;
                }
            // W-Frames:
            case 'WCOM':
            case 'WCOP':
            case 'WOAF':
            case 'WOAR':
            case 'WOAS':
            case 'WORS':
            case 'WPAY':
            case 'WPUB':
                // Decode URL
                fzero = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset + 1, length, encoding);
                output = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset, fzero), defaultEnc);
                break;
            case 'WXXX':
                {
                    // Decode URL
                    fzero = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset + 1, length, encoding);
                    const description = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset + 1, fzero), encoding);
                    offset = fzero + (encoding === 'utf-16le' ? 2 : 1);
                    output = {
                        description,
                        url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset, length), defaultEnc)
                    };
                    break;
                }
            case 'WFD':
            case 'WFED':
                output = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset + 1, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset + 1, length, encoding)), encoding);
                break;
            case 'MCDI':
                {
                    // Music CD identifier
                    output = uint8Array.subarray(0, length);
                    break;
                }
            default:
                debug(`Warning: unsupported id3v2-tag-type: ${type}`);
                break;
        }
        return output;
    }
    static readNullTerminatedString(uint8Array, encoding) {
        let offset = encoding.bom ? 2 : 0;
        const zeroIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset, uint8Array.length, encoding.encoding);
        const txt = uint8Array.subarray(offset, zeroIndex);
        if (encoding.encoding === 'utf-16le') {
            offset = zeroIndex + 2;
        } else {
            offset = zeroIndex + 1;
        }
        return {
            text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](txt, encoding.encoding),
            len: offset
        };
    }
    static fixPictureMimeType(pictureType) {
        pictureType = pictureType.toLocaleLowerCase();
        switch(pictureType){
            case 'jpg':
                return 'image/jpeg';
            case 'png':
                return 'image/png';
        }
        return pictureType;
    }
    /**
     * Converts TMCL (Musician credits list) or TIPL (Involved people list)
     * @param entries
     */ static functionList(entries) {
        const res = {};
        for(let i = 0; i + 1 < entries.length; i += 2){
            const names = entries[i + 1].split(',');
            res[entries[i]] = res[entries[i]] ? res[entries[i]].concat(names) : names;
        }
        return res;
    }
    /**
     * id3v2.4 defines that multiple T* values are separated by 0x00
     * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
     * @param tag - Tag name
     * @param text - Concatenated tag value
     * @returns Split tag value
     */ splitValue(tag, text) {
        let values;
        if (this.major < 4) {
            values = text.split(/\x00/g);
            if (values.length > 1) {
                this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);
            } else {
                values = text.split(/\//g);
            }
        } else {
            values = text.split(/\x00/g);
        }
        return FrameParser.trimArray(values);
    }
    static trimArray(values) {
        return values.map((value)=>value.replace(/\x00+$/, '').trim());
    }
    static readIdentifierAndData(uint8Array, offset, length, encoding) {
        const fzero = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findZero"](uint8Array, offset, length, encoding);
        const id = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeString"](uint8Array.subarray(offset, fzero), encoding);
        offset = fzero + FrameParser.getNullTerminatorLength(encoding);
        return {
            id,
            data: uint8Array.subarray(offset, length)
        };
    }
    static getNullTerminatorLength(enc) {
        return enc === 'utf-16le' ? 2 : 1;
    }
}
class Id3v2ContentError extends (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$ParseError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["makeUnexpectedFileContentError"])('id3v2') {
}
function makeUnexpectedMajorVersionError(majorVer) {
    throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);
}
}),
"[project]/node_modules/music-metadata/lib/id3v2/ID3v2Parser.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ID3v2Parser",
    ()=>ID3v2Parser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/token-types/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/common/Util.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$FrameParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/id3v2/FrameParser.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/id3v2/ID3v2Token.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$borewit$2f$text$2d$codec$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@borewit/text-codec/lib/index.js [app-route] (ecmascript)");
;
;
;
;
;
class ID3v2Parser {
    constructor(){
        this.tokenizer = undefined;
        this.id3Header = undefined;
        this.metadata = undefined;
        this.headerType = undefined;
        this.options = undefined;
    }
    static removeUnsyncBytes(buffer) {
        let readI = 0;
        let writeI = 0;
        while(readI < buffer.length - 1){
            if (readI !== writeI) {
                buffer[writeI] = buffer[readI];
            }
            readI += buffer[readI] === 0xFF && buffer[readI + 1] === 0 ? 2 : 1;
            writeI++;
        }
        if (readI < buffer.length) {
            buffer[writeI++] = buffer[readI];
        }
        return buffer.subarray(0, writeI);
    }
    static getFrameHeaderLength(majorVer) {
        switch(majorVer){
            case 2:
                return 6;
            case 3:
            case 4:
                return 10;
            default:
                throw makeUnexpectedMajorVersionError(majorVer);
        }
    }
    static readFrameFlags(b) {
        return {
            status: {
                tag_alter_preservation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBit"](b, 0, 6),
                file_alter_preservation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBit"](b, 0, 5),
                read_only: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBit"](b, 0, 4)
            },
            format: {
                grouping_identity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBit"](b, 1, 7),
                compression: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBit"](b, 1, 3),
                encryption: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBit"](b, 1, 2),
                unsynchronisation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBit"](b, 1, 1),
                data_length_indicator: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBit"](b, 1, 0)
            }
        };
    }
    static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {
        const frameParser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$FrameParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FrameParser"](majorVer, warningCollector);
        switch(majorVer){
            case 2:
                return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
            case 3:
            case 4:
                if (frameHeader.flags?.format.unsynchronisation) {
                    uint8Array = ID3v2Parser.removeUnsyncBytes(uint8Array);
                }
                if (frameHeader.flags?.format.data_length_indicator) {
                    uint8Array = uint8Array.subarray(4, uint8Array.length);
                }
                return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
            default:
                throw makeUnexpectedMajorVersionError(majorVer);
        }
    }
    /**
     * Create a combined tag key, of tag & description
     * @param tag e.g.: COM
     * @param description e.g. iTunPGAP
     * @returns string e.g. COM:iTunPGAP
     */ static makeDescriptionTagName(tag, description) {
        return tag + (description ? `:${description}` : '');
    }
    async parse(metadata, tokenizer, options) {
        this.tokenizer = tokenizer;
        this.metadata = metadata;
        this.options = options;
        const id3Header = await this.tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ID3v2Header"]);
        if (id3Header.fileIdentifier !== 'ID3') {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$FrameParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Id3v2ContentError"]('expected ID3-header file-identifier \'ID3\' was not found');
        }
        this.id3Header = id3Header;
        this.headerType = `ID3v2.${id3Header.version.major}`;
        return id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size);
    }
    async parseExtendedHeader() {
        const extendedHeader = await this.tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtendedHeader"]);
        const dataRemaining = extendedHeader.size - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtendedHeader"].len;
        return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);
    }
    async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {
        await this.tokenizer.ignore(dataRemaining);
        return this.parseId3Data(this.id3Header.size - extendedHeaderSize);
    }
    async parseId3Data(dataLen) {
        const uint8Array = await this.tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Uint8ArrayType"](dataLen));
        for (const tag of this.parseMetadata(uint8Array)){
            switch(tag.id){
                case 'TXXX':
                    if (tag.value) {
                        await this.handleTag(tag, tag.value.text, ()=>tag.value.description);
                    }
                    break;
                default:
                    await (Array.isArray(tag.value) ? Promise.all(tag.value.map((value)=>this.addTag(tag.id, value))) : this.addTag(tag.id, tag.value));
            }
        }
    }
    async handleTag(tag, values, descriptor, resolveValue = (value)=>value) {
        await Promise.all(values.map((value)=>this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, descriptor(value)), resolveValue(value))));
    }
    async addTag(id, value) {
        await this.metadata.addTag(this.headerType, id, value);
    }
    parseMetadata(data) {
        let offset = 0;
        const tags = [];
        while(true){
            if (offset === data.length) break;
            const frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
            if (offset + frameHeaderLength > data.length) {
                this.metadata.addWarning('Illegal ID3v2 tag length');
                break;
            }
            const frameHeaderBytes = data.subarray(offset, offset + frameHeaderLength);
            offset += frameHeaderLength;
            const frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);
            const frameDataBytes = data.subarray(offset, offset + frameHeader.length);
            offset += frameHeader.length;
            const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
            if (values) {
                tags.push({
                    id: frameHeader.id,
                    value: values
                });
            }
        }
        return tags;
    }
    readFrameHeader(uint8Array, majorVer) {
        let header;
        switch(majorVer){
            case 2:
                header = {
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$borewit$2f$text$2d$codec$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textDecode"])(uint8Array.subarray(0, 3), 'ascii'),
                    length: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT24_BE"].get(uint8Array, 3)
                };
                if (!header.id.match(/[A-Z0-9]{3}/g)) {
                    this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
                }
                break;
            case 3:
            case 4:
                header = {
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$borewit$2f$text$2d$codec$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textDecode"])(uint8Array.subarray(0, 4), 'ascii'),
                    length: (majorVer === 4 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32SYNCSAFE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_BE"]).get(uint8Array, 4),
                    flags: ID3v2Parser.readFrameFlags(uint8Array.subarray(8, 10))
                };
                if (!header.id.match(/[A-Z0-9]{4}/g)) {
                    this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
                }
                break;
            default:
                throw makeUnexpectedMajorVersionError(majorVer);
        }
        return header;
    }
}
function makeUnexpectedMajorVersionError(majorVer) {
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$FrameParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Id3v2ContentError"](`Unexpected majorVer: ${majorVer}`);
}
}),
"[project]/node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractID3Parser",
    ()=>AbstractID3Parser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strtok3$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/strtok3/lib/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/strtok3/lib/core.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/id3v2/ID3v2Token.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/id3v2/ID3v2Parser.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v1$2f$ID3v1Parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/id3v1/ID3v1Parser.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$BasicParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/common/BasicParser.js [app-route] (ecmascript)");
;
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])('music-metadata:parser:ID3');
class AbstractID3Parser extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$BasicParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BasicParser"] {
    constructor(){
        super(...arguments);
        this.id3parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ID3v2Parser"]();
    }
    static async startsWithID3v2Header(tokenizer) {
        return (await tokenizer.peekToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ID3v2Header"])).fileIdentifier === 'ID3';
    }
    async parse() {
        try {
            await this.parseID3v2();
        } catch (err) {
            if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]) {
                debug("End-of-stream");
            } else {
                throw err;
            }
        }
    }
    finalize() {
        return;
    }
    async parseID3v2() {
        await this.tryReadId3v2Headers();
        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);
        await this.postId3v2Parse();
        if (this.options.skipPostHeaders && this.metadata.hasAny()) {
            this.finalize();
        } else {
            const id3v1parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v1$2f$ID3v1Parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ID3v1Parser"](this.metadata, this.tokenizer, this.options);
            await id3v1parser.parse();
            this.finalize();
        }
    }
    async tryReadId3v2Headers() {
        const id3Header = await this.tokenizer.peekToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$ID3v2Token$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ID3v2Header"]);
        if (id3Header.fileIdentifier === 'ID3') {
            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);
            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);
            return this.tryReadId3v2Headers();
        }
    }
}
}),
"[project]/node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReplayGain",
    ()=>ReplayGain
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/common/Util.js [app-route] (ecmascript)");
;
/**
 * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#name-code
 */ const NameCode = {
    /**
     * not set
     */ not_set: 0,
    /**
     * Radio Gain Adjustment
     */ radio: 1,
    /**
     * Audiophile Gain Adjustment
     */ audiophile: 2
};
/**
 * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#originator-code
 */ const ReplayGainOriginator = {
    /**
     * Replay Gain unspecified
     */ unspecified: 0,
    /**
     * Replay Gain pre-set by artist/producer/mastering engineer
     */ engineer: 1,
    /**
     * Replay Gain set by user
     */ user: 2,
    /**
     * Replay Gain determined automatically, as described on this site
     */ automatic: 3,
    /**
     * Set by simple RMS average
     */ rms_average: 4
};
const ReplayGain = {
    len: 2,
    get: (buf, off)=>{
        const gain_type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off, 0, 3);
        const sign = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off, 6, 1);
        const gain_adj = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off, 7, 9) / 10.0;
        if (gain_type > 0) {
            return {
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off, 0, 3),
                origin: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off, 3, 3),
                adjustment: sign ? -gain_adj : gain_adj
            };
        }
        return undefined;
    }
};
}),
"[project]/node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Extended Lame Header
 */ __turbopack_context__.s([
    "ExtendedLameHeader",
    ()=>ExtendedLameHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/token-types/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/common/Util.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$ReplayGainDataFormat$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js [app-route] (ecmascript)");
;
;
;
const ExtendedLameHeader = {
    len: 27,
    get: (buf, off)=>{
        const track_peak = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_BE"].get(buf, off + 2);
        return {
            revision: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off, 0, 4),
            vbr_method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off, 4, 4),
            lowpass_filter: 100 * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT8"].get(buf, off + 1),
            track_peak: track_peak === 0 ? null : track_peak / 2 ** 23,
            track_gain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$ReplayGainDataFormat$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ReplayGain"].get(buf, 6),
            album_gain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$ReplayGainDataFormat$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ReplayGain"].get(buf, 8),
            music_length: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_BE"].get(buf, off + 20),
            music_crc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT8"].get(buf, off + 24),
            header_crc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_BE"].get(buf, off + 24)
        };
    }
};
}),
"[project]/node_modules/music-metadata/lib/mpeg/XingTag.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InfoTagHeaderTag",
    ()=>InfoTagHeaderTag,
    "LameEncoderVersion",
    ()=>LameEncoderVersion,
    "XingHeaderFlags",
    ()=>XingHeaderFlags,
    "readXingHeader",
    ()=>readXingHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/token-types/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/common/Util.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$ExtendedLameHeader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js [app-route] (ecmascript)");
;
;
;
const InfoTagHeaderTag = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](4, 'ascii');
const LameEncoderVersion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](6, 'ascii');
const XingHeaderFlags = {
    len: 4,
    get: (buf, off)=>{
        return {
            frames: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBitSet"](buf, off, 31),
            bytes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBitSet"](buf, off, 30),
            toc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBitSet"](buf, off, 29),
            vbrScale: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBitSet"](buf, off, 28)
        };
    }
};
async function readXingHeader(tokenizer) {
    const flags = await tokenizer.readToken(XingHeaderFlags);
    const xingInfoTag = {
        numFrames: null,
        streamSize: null,
        vbrScale: null
    };
    if (flags.frames) {
        xingInfoTag.numFrames = await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_BE"]);
    }
    if (flags.bytes) {
        xingInfoTag.streamSize = await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_BE"]);
    }
    if (flags.toc) {
        xingInfoTag.toc = new Uint8Array(100);
        await tokenizer.readBuffer(xingInfoTag.toc);
    }
    if (flags.vbrScale) {
        xingInfoTag.vbrScale = await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_BE"]);
    }
    const lameTag = await tokenizer.peekToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](4, 'ascii'));
    if (lameTag === 'LAME') {
        await tokenizer.ignore(4);
        xingInfoTag.lame = {
            version: await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](5, 'ascii'))
        };
        const match = xingInfoTag.lame.version.match(/\d+.\d+/g);
        if (match !== null) {
            const majorMinorVersion = match[0]; // e.g. 3.97
            const version = majorMinorVersion.split('.').map((n)=>Number.parseInt(n, 10));
            if (version[0] >= 3 && version[1] >= 90) {
                xingInfoTag.lame.extended = await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$ExtendedLameHeader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtendedLameHeader"]);
            }
        }
    }
    return xingInfoTag;
}
}),
"[project]/node_modules/music-metadata/lib/mpeg/MpegParser.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MpegContentError",
    ()=>MpegContentError,
    "MpegParser",
    ()=>MpegParser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/token-types/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strtok3$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/strtok3/lib/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/strtok3/lib/core.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/common/Util.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$AbstractID3Parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$XingTag$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/mpeg/XingTag.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$ParseError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/music-metadata/lib/ParseError.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])('music-metadata:parser:mpeg');
class MpegContentError extends (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$ParseError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["makeUnexpectedFileContentError"])('MPEG') {
}
/**
 * Cache buffer size used for searching synchronization preabmle
 */ const maxPeekLen = 1024;
/**
 * MPEG-4 Audio definitions
 * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio
 */ const MPEG4 = {
    /**
     * Audio Object Types
     */ AudioObjectTypes: [
        'AAC Main',
        'AAC LC',
        'AAC SSR',
        'AAC LTP' // Long Term Prediction
    ],
    /**
     * Sampling Frequencies
     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
     */ SamplingFrequencies: [
        96000,
        88200,
        64000,
        48000,
        44100,
        32000,
        24000,
        22050,
        16000,
        12000,
        11025,
        8000,
        7350,
        null,
        null,
        -1
    ]
};
const MPEG4_ChannelConfigurations = [
    undefined,
    [
        'front-center'
    ],
    [
        'front-left',
        'front-right'
    ],
    [
        'front-center',
        'front-left',
        'front-right'
    ],
    [
        'front-center',
        'front-left',
        'front-right',
        'back-center'
    ],
    [
        'front-center',
        'front-left',
        'front-right',
        'back-left',
        'back-right'
    ],
    [
        'front-center',
        'front-left',
        'front-right',
        'back-left',
        'back-right',
        'LFE-channel'
    ],
    [
        'front-center',
        'front-left',
        'front-right',
        'side-left',
        'side-right',
        'back-left',
        'back-right',
        'LFE-channel'
    ]
];
/**
 * MPEG Audio Layer I/II/III frame header
 * Ref: https://www.mp3-tech.org/programmer/frame_header.html
 * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM
 * Ref: https://wiki.multimedia.cx/index.php/ADTS
 */ class MpegFrameHeader {
    constructor(buf, off){
        // E(15,12): Bitrate index
        this.bitrateIndex = null;
        // F(11,10): Sampling rate frequency index
        this.sampRateFreqIndex = null;
        // G(9): Padding bit
        this.padding = null;
        // H(8): Private bit
        this.privateBit = null;
        // I(7,6): Channel Mode
        this.channelModeIndex = null;
        // J(5,4): Mode extension (Only used in Joint stereo)
        this.modeExtension = null;
        // L(2): Original
        this.isOriginalMedia = null;
        this.version = null;
        this.bitrate = null;
        this.samplingRate = null;
        this.frameLength = 0;
        // B(20,19): MPEG Audio versionIndex ID
        this.versionIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 1, 3, 2);
        // C(18,17): Layer description
        this.layer = MpegFrameHeader.LayerDescription[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 1, 5, 2)];
        if (this.versionIndex > 1 && this.layer === 0) {
            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)
        } else {
            this.parseMpegHeader(buf, off); // Conventional MPEG header
        }
        // D(16): Protection bit (if true 16-bit CRC follows header)
        this.isProtectedByCRC = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBitSet"](buf, off + 1, 7);
    }
    calcDuration(numFrames) {
        return this.samplingRate == null ? null : numFrames * this.calcSamplesPerFrame() / this.samplingRate;
    }
    calcSamplesPerFrame() {
        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
    }
    calculateSideInfoLength() {
        if (this.layer !== 3) return 2;
        if (this.channelModeIndex === 3) {
            // mono
            if (this.version === 1) {
                return 17;
            }
            if (this.version === 2 || this.version === 2.5) {
                return 9;
            }
        } else {
            if (this.version === 1) {
                return 32;
            }
            if (this.version === 2 || this.version === 2.5) {
                return 17;
            }
        }
        return null;
    }
    calcSlotSize() {
        return [
            null,
            4,
            1,
            1
        ][this.layer];
    }
    parseMpegHeader(buf, off) {
        this.container = 'MPEG';
        // E(15,12): Bitrate index
        this.bitrateIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 2, 0, 4);
        // F(11,10): Sampling rate frequency index
        this.sampRateFreqIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 2, 4, 2);
        // G(9): Padding bit
        this.padding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBitSet"](buf, off + 2, 6);
        // H(8): Private bit
        this.privateBit = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBitSet"](buf, off + 2, 7);
        // I(7,6): Channel Mode
        this.channelModeIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 3, 0, 2);
        // J(5,4): Mode extension (Only used in Joint stereo)
        this.modeExtension = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 3, 2, 2);
        // K(3): Copyright
        this.isCopyrighted = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBitSet"](buf, off + 3, 4);
        // L(2): Original
        this.isOriginalMedia = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isBitSet"](buf, off + 3, 5);
        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.
        this.emphasis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 3, 7, 2);
        this.version = MpegFrameHeader.VersionID[this.versionIndex];
        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
        this.codec = `MPEG ${this.version} Layer ${this.layer}`;
        // Calculate bitrate
        const bitrateInKbps = this.calcBitrate();
        if (!bitrateInKbps) {
            throw new MpegContentError('Cannot determine bit-rate');
        }
        this.bitrate = bitrateInKbps * 1000;
        // Calculate sampling rate
        this.samplingRate = this.calcSamplingRate();
        if (this.samplingRate == null) {
            throw new MpegContentError('Cannot determine sampling-rate');
        }
    }
    parseAdtsHeader(buf, off) {
        debug("layer=0 => ADTS");
        this.version = this.versionIndex === 2 ? 4 : 2;
        this.container = `ADTS/MPEG-${this.version}`;
        const profileIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 2, 0, 2);
        this.codec = 'AAC';
        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];
        debug(`MPEG-4 audio-codec=${this.codec}`);
        const samplingFrequencyIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 2, 2, 4);
        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];
        debug(`sampling-rate=${this.samplingRate}`);
        const channelIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 2, 7, 3);
        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];
        debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join('+') : '?'}`);
        this.frameLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, off + 3, 6, 2) << 11;
    }
    calcBitrate() {
        if (this.bitrateIndex === 0x00 || // free
        this.bitrateIndex === 0x0F) {
            return null;
        }
        if (this.version && this.bitrateIndex) {
            const codecIndex = 10 * Math.floor(this.version) + this.layer;
            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];
        }
        return null;
    }
    calcSamplingRate() {
        if (this.sampRateFreqIndex === 0x03 || this.version === null || this.sampRateFreqIndex == null) return null; // 'reserved'
        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
    }
}
MpegFrameHeader.SyncByte1 = 0xFF;
MpegFrameHeader.SyncByte2 = 0xE0;
MpegFrameHeader.VersionID = [
    2.5,
    null,
    2,
    1
];
MpegFrameHeader.LayerDescription = [
    0,
    3,
    2,
    1
];
MpegFrameHeader.ChannelMode = [
    'stereo',
    'joint_stereo',
    'dual_channel',
    'mono'
];
MpegFrameHeader.bitrate_index = {
    1: {
        11: 32,
        12: 32,
        13: 32,
        21: 32,
        22: 8,
        23: 8
    },
    2: {
        11: 64,
        12: 48,
        13: 40,
        21: 48,
        22: 16,
        23: 16
    },
    3: {
        11: 96,
        12: 56,
        13: 48,
        21: 56,
        22: 24,
        23: 24
    },
    4: {
        11: 128,
        12: 64,
        13: 56,
        21: 64,
        22: 32,
        23: 32
    },
    5: {
        11: 160,
        12: 80,
        13: 64,
        21: 80,
        22: 40,
        23: 40
    },
    6: {
        11: 192,
        12: 96,
        13: 80,
        21: 96,
        22: 48,
        23: 48
    },
    7: {
        11: 224,
        12: 112,
        13: 96,
        21: 112,
        22: 56,
        23: 56
    },
    8: {
        11: 256,
        12: 128,
        13: 112,
        21: 128,
        22: 64,
        23: 64
    },
    9: {
        11: 288,
        12: 160,
        13: 128,
        21: 144,
        22: 80,
        23: 80
    },
    10: {
        11: 320,
        12: 192,
        13: 160,
        21: 160,
        22: 96,
        23: 96
    },
    11: {
        11: 352,
        12: 224,
        13: 192,
        21: 176,
        22: 112,
        23: 112
    },
    12: {
        11: 384,
        12: 256,
        13: 224,
        21: 192,
        22: 128,
        23: 128
    },
    13: {
        11: 416,
        12: 320,
        13: 256,
        21: 224,
        22: 144,
        23: 144
    },
    14: {
        11: 448,
        12: 384,
        13: 320,
        21: 256,
        22: 160,
        23: 160
    }
};
MpegFrameHeader.sampling_rate_freq_index = {
    1: {
        0: 44100,
        1: 48000,
        2: 32000
    },
    2: {
        0: 22050,
        1: 24000,
        2: 16000
    },
    2.5: {
        0: 11025,
        1: 12000,
        2: 8000
    }
};
MpegFrameHeader.samplesInFrameTable = [
    /* Layer   I    II   III */ [
        0,
        384,
        1152,
        1152
    ],
    [
        0,
        384,
        1152,
        576
    ] // MPEG-2(.5
];
/**
 * MPEG Audio Layer I/II/III
 */ const FrameHeader = {
    len: 4,
    get: (buf, off)=>{
        return new MpegFrameHeader(buf, off);
    }
};
function getVbrCodecProfile(vbrScale) {
    return `V${Math.floor((100 - vbrScale) / 10)}`;
}
class MpegParser extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$id3v2$2f$AbstractID3Parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbstractID3Parser"] {
    constructor(){
        super(...arguments);
        this.frameCount = 0;
        this.syncFrameCount = -1;
        this.countSkipFrameData = 0;
        this.totalDataLength = 0;
        this.bitrates = [];
        this.offset = 0;
        this.frame_size = 0;
        this.crc = null;
        this.calculateEofDuration = false;
        this.samplesPerFrame = null;
        this.buf_frame_header = new Uint8Array(4);
        /**
         * Number of bytes already parsed since beginning of stream / file
         */ this.mpegOffset = null;
        this.syncPeek = {
            buf: new Uint8Array(maxPeekLen),
            len: 0
        };
    }
    /**
     * Called after ID3 headers have been parsed
     */ async postId3v2Parse() {
        this.metadata.setFormat('lossless', false);
        this.metadata.setAudioOnly();
        try {
            let quit = false;
            while(!quit){
                await this.sync();
                quit = await this.parseCommonMpegHeader();
            }
        } catch (err) {
            if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]) {
                debug("End-of-stream");
                if (this.calculateEofDuration) {
                    if (this.samplesPerFrame !== null) {
                        const numberOfSamples = this.frameCount * this.samplesPerFrame;
                        this.metadata.setFormat('numberOfSamples', numberOfSamples);
                        if (this.metadata.format.sampleRate) {
                            const duration = numberOfSamples / this.metadata.format.sampleRate;
                            debug(`Calculate duration at EOF: ${duration} sec.`, duration);
                            this.metadata.setFormat('duration', duration);
                        }
                    }
                }
            } else {
                throw err;
            }
        }
    }
    /**
     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
     */ finalize() {
        const format = this.metadata.format;
        const hasID3v1 = !!this.metadata.native.ID3v1;
        if (this.mpegOffset !== null) {
            if (format.duration && this.tokenizer.fileInfo.size) {
                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
                if (format.codecProfile && format.codecProfile[0] === 'V') {
                    this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);
                }
            }
            if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {
                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
                if (this.frame_size !== null && this.samplesPerFrame !== null) {
                    const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;
                    this.metadata.setFormat('numberOfSamples', numberOfSamples);
                    if (format.sampleRate && !format.duration) {
                        const duration = numberOfSamples / format.sampleRate;
                        debug("Calculate CBR duration based on file size: %s", duration);
                        this.metadata.setFormat('duration', duration);
                    }
                }
            }
        }
    }
    async sync() {
        let gotFirstSync = false;
        while(true){
            let bo = 0;
            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, {
                length: maxPeekLen,
                mayBeLess: true
            });
            if (this.syncPeek.len <= 163) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
            }
            while(true){
                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {
                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;
                    this.buf_frame_header[1] = this.syncPeek.buf[bo];
                    await this.tokenizer.ignore(bo);
                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);
                    if (this.syncFrameCount === this.frameCount) {
                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);
                        this.frameCount = 0;
                        this.frame_size = 0;
                    }
                    this.syncFrameCount = this.frameCount;
                    return; // sync
                }
                gotFirstSync = false;
                bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);
                if (bo === -1) {
                    if (this.syncPeek.len < this.syncPeek.buf.length) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
                    }
                    await this.tokenizer.ignore(this.syncPeek.len);
                    break; // continue with next buffer
                }
                ++bo;
                gotFirstSync = true;
            }
        }
    }
    /**
     * Combined ADTS & MPEG (MP2 & MP3) header handling
     * @return {Promise<boolean>} true if parser should quit
     */ async parseCommonMpegHeader() {
        if (this.frameCount === 0) {
            this.mpegOffset = this.tokenizer.position - 1;
        }
        await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), {
            length: 3
        });
        let header;
        try {
            header = FrameHeader.get(this.buf_frame_header, 0);
        } catch (err) {
            await this.tokenizer.ignore(1);
            if (err instanceof Error) {
                this.metadata.addWarning(`Parse error: ${err.message}`);
                return false; // sync
            }
            throw err;
        }
        await this.tokenizer.ignore(3);
        this.metadata.setFormat('container', header.container);
        this.metadata.setFormat('codec', header.codec);
        this.metadata.setFormat('lossless', false);
        this.metadata.setFormat('sampleRate', header.samplingRate);
        this.frameCount++;
        return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);
    }
    /**
     * @return {Promise<boolean>} true if parser should quit
     */ async parseAudioFrameHeader(header) {
        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);
        this.metadata.setFormat('bitrate', header.bitrate);
        if (this.frameCount < 20 * 10000) {
            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
        }
        const slot_size = header.calcSlotSize();
        if (slot_size === null) {
            throw new MpegContentError('invalid slot_size');
        }
        const samples_per_frame = header.calcSamplesPerFrame();
        debug(`samples_per_frame=${samples_per_frame}`);
        const bps = samples_per_frame / 8.0;
        if (header.bitrate !== null && header.samplingRate != null) {
            const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);
            this.frame_size = Math.floor(fsize);
        }
        this.audioFrameHeader = header;
        if (header.bitrate !== null) {
            this.bitrates.push(header.bitrate);
        }
        // xtra header only exists in first frame
        if (this.frameCount === 1) {
            this.offset = FrameHeader.len;
            await this.skipSideInformation();
            return false;
        }
        if (this.frameCount === 4) {
            // the stream is CBR if the first 3 frame bitrates are the same
            if (this.areAllSame(this.bitrates)) {
                // Actual calculation will be done in finalize
                this.samplesPerFrame = samples_per_frame;
                this.metadata.setFormat('codecProfile', 'CBR');
                if (this.tokenizer.fileInfo.size) return true; // Will calculate duration based on the file size
            } else if (this.metadata.format.duration) {
                return true; // We already got the duration, stop processing MPEG stream any further
            }
            if (!this.options.duration) {
                return true; // Enforce duration not enabled, stop processing entire stream
            }
        }
        // once we know the file is VBR attach listener to end of
        // stream so we can do the duration calculation when we
        // have counted all the frames
        if (this.options.duration && this.frameCount === 4) {
            this.samplesPerFrame = samples_per_frame;
            this.calculateEofDuration = true;
        }
        this.offset = 4;
        if (header.isProtectedByCRC) {
            await this.parseCrc();
            return false;
        }
        await this.skipSideInformation();
        return false;
    }
    async parseAdts(header) {
        const buf = new Uint8Array(3);
        await this.tokenizer.readBuffer(buf);
        header.frameLength += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBitAllignedNumber"](buf, 0, 0, 11);
        this.totalDataLength += header.frameLength;
        this.samplesPerFrame = 1024;
        if (header.samplingRate !== null) {
            const framesPerSec = header.samplingRate / this.samplesPerFrame;
            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;
            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;
            this.metadata.setFormat('bitrate', bitrate);
            debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);
        }
        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);
        // Consume remaining header and frame data
        if (this.frameCount === 3) {
            this.metadata.setFormat('codecProfile', header.codecProfile);
            if (header.mp4ChannelConfig) {
                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);
            }
            if (this.options.duration) {
                this.calculateEofDuration = true;
            } else {
                return true; // Stop parsing after the third frame
            }
        }
        return false;
    }
    async parseCrc() {
        this.crc = await this.tokenizer.readNumber(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["INT16_BE"]);
        this.offset += 2;
        return this.skipSideInformation();
    }
    async skipSideInformation() {
        if (this.audioFrameHeader) {
            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
            if (sideinfo_length !== null) {
                await this.tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Uint8ArrayType"](sideinfo_length));
                // side information
                this.offset += sideinfo_length;
                await this.readXtraInfoHeader();
                return;
            }
        }
    }
    async readXtraInfoHeader() {
        const headerTag = await this.tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$XingTag$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InfoTagHeaderTag"]);
        this.offset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$XingTag$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InfoTagHeaderTag"].len; // 12
        switch(headerTag){
            case 'Info':
                this.metadata.setFormat('codecProfile', 'CBR');
                return this.readXingInfoHeader();
            case 'Xing':
                {
                    const infoTag = await this.readXingInfoHeader();
                    if (infoTag.vbrScale !== null) {
                        const codecProfile = getVbrCodecProfile(infoTag.vbrScale);
                        this.metadata.setFormat('codecProfile', codecProfile);
                    }
                    return null;
                }
            case 'Xtra':
                break;
            case 'LAME':
                {
                    const version = await this.tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$XingTag$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LameEncoderVersion"]);
                    if (this.frame_size !== null && this.frame_size >= this.offset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$XingTag$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LameEncoderVersion"].len) {
                        this.offset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$XingTag$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LameEncoderVersion"].len;
                        this.metadata.setFormat('tool', `LAME ${version}`);
                        await this.skipFrameData(this.frame_size - this.offset);
                        return null;
                    }
                    this.metadata.addWarning('Corrupt LAME header');
                    break;
                }
        }
        // ToDo: promise duration???
        const frameDataLeft = this.frame_size - this.offset;
        if (frameDataLeft < 0) {
            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);
        } else {
            await this.skipFrameData(frameDataLeft);
        }
        return null;
    }
    /**
     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
     * @returns {Promise<string>}
     */ async readXingInfoHeader() {
        const offset = this.tokenizer.position;
        const infoTag = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$mpeg$2f$XingTag$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readXingHeader"])(this.tokenizer);
        this.offset += this.tokenizer.position - offset;
        if (infoTag.lame) {
            this.metadata.setFormat('tool', `LAME ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$music$2d$metadata$2f$lib$2f$common$2f$Util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stripNulls"](infoTag.lame.version)}`);
            if (infoTag.lame.extended) {
                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);
                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);
                if (infoTag.lame.extended.track_gain) {
                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);
                }
                if (infoTag.lame.extended.album_gain) {
                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);
                }
                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);
            }
        }
        if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {
            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);
            this.metadata.setFormat('duration', duration);
            debug('Get duration from Xing header: %s', this.metadata.format.duration);
            return infoTag;
        }
        // frames field is not present
        const frameDataLeft = this.frame_size - this.offset;
        await this.skipFrameData(frameDataLeft);
        return infoTag;
    }
    async skipFrameData(frameDataLeft) {
        if (frameDataLeft < 0) throw new MpegContentError('frame-data-left cannot be negative');
        await this.tokenizer.ignore(frameDataLeft);
        this.countSkipFrameData += frameDataLeft;
    }
    areAllSame(array) {
        const first = array[0];
        return array.every((element)=>{
            return element === first;
        });
    }
}
}),
];

//# sourceMappingURL=node_modules_music-metadata_lib_a4e00741._.js.map
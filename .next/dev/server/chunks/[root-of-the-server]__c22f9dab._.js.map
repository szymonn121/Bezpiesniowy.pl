{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Szymon/Desktop/bezpiesniowy/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined;\r\n};\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  globalForPrisma.prisma = prisma;\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B","debugId":null}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Szymon/Desktop/bezpiesniowy/src/lib/auth.ts"],"sourcesContent":["import bcrypt from \"bcryptjs\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { UserRole } from \"@prisma/client\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\nconst TOKEN_COOKIE = \"bezpiesniowy_token\";\r\n\r\nexport interface AuthTokenPayload {\r\n  userId: number;\r\n  email: string;\r\n  role: UserRole;\r\n}\r\n\r\nfunction getJwtSecret(): string {\r\n  const secret = process.env.JWT_SECRET;\r\n  if (!secret) {\r\n    throw new Error(\"JWT_SECRET must be set\");\r\n  }\r\n  return secret;\r\n}\r\n\r\nexport async function hashPassword(plain: string): Promise<string> {\r\n  return bcrypt.hash(plain, 10);\r\n}\r\n\r\nexport async function verifyPassword(plain: string, hash: string): Promise<boolean> {\r\n  return bcrypt.compare(plain, hash);\r\n}\r\n\r\nexport function signAuthToken(payload: AuthTokenPayload, expiresIn = \"7d\"): string {\r\n  return jwt.sign(payload, getJwtSecret(), { expiresIn });\r\n}\r\n\r\nexport function verifyAuthToken(token: string): AuthTokenPayload | null {\r\n  try {\r\n    return jwt.verify(token, getJwtSecret()) as AuthTokenPayload;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function extractTokenFromHeader(header?: string | null): string | null {\r\n  if (!header) {\r\n    return null;\r\n  }\r\n  const [type, token] = header.split(\" \");\r\n  if (type?.toLowerCase() !== \"bearer\" || !token) {\r\n    return null;\r\n  }\r\n  return token;\r\n}\r\n\r\nexport function getTokenFromCookies(request: NextRequest): string | null {\r\n  return request.cookies.get(TOKEN_COOKIE)?.value ?? null;\r\n}\r\n\r\nexport { TOKEN_COOKIE };\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;;;AAIA,MAAM,eAAe;AAQrB,SAAS;IACP,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;IACrC,IAAI,CAAC,QAAQ;QACX,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEO,eAAe,aAAa,KAAa;IAC9C,OAAO,8IAAM,CAAC,IAAI,CAAC,OAAO;AAC5B;AAEO,eAAe,eAAe,KAAa,EAAE,IAAY;IAC9D,OAAO,8IAAM,CAAC,OAAO,CAAC,OAAO;AAC/B;AAEO,SAAS,cAAc,OAAyB,EAAE,YAAY,IAAI;IACvE,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,gBAAgB;QAAE;IAAU;AACvD;AAEO,SAAS,gBAAgB,KAAa;IAC3C,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS,uBAAuB,MAAsB;IAC3D,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IACA,MAAM,CAAC,MAAM,MAAM,GAAG,OAAO,KAAK,CAAC;IACnC,IAAI,MAAM,kBAAkB,YAAY,CAAC,OAAO;QAC9C,OAAO;IACT;IACA,OAAO;AACT;AAEO,SAAS,oBAAoB,OAAoB;IACtD,OAAO,QAAQ,OAAO,CAAC,GAAG,CAAC,eAAe,SAAS;AACrD","debugId":null}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Szymon/Desktop/bezpiesniowy/src/lib/server-auth.ts"],"sourcesContent":["import type { NextRequest } from \"next/server\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { TOKEN_COOKIE, extractTokenFromHeader, getTokenFromCookies, verifyAuthToken } from \"@/lib/auth\";\r\n\r\nexport async function getUserFromRequest(request: NextRequest) {\r\n  const headerToken = extractTokenFromHeader(request.headers.get(\"authorization\"));\r\n  const cookieToken = getTokenFromCookies(request);\r\n  const token = headerToken ?? cookieToken;\r\n\r\n  if (!token) return null;\r\n  const payload = verifyAuthToken(token);\r\n  if (!payload) return null;\r\n\r\n  return prisma.user.findUnique({\r\n    where: { id: payload.userId },\r\n  });\r\n}\r\n\r\nexport async function requireAdmin(request: NextRequest) {\r\n  const user = await getUserFromRequest(request);\r\n  if (!user || user.role !== \"ADMIN\") {\r\n    return null;\r\n  }\r\n  return user;\r\n}\r\n\r\n// üß© uniwersalna wersja getCurrentUserFromCookies\r\nexport async function getCurrentUserFromCookies(req?: any) {\r\n  let token: string | undefined;\r\n\r\n  try {\r\n    // Pr√≥ba u≈ºycia App Router API\r\n    const { cookies } = await import(\"next/headers\");\r\n    // `cookies()` is async in this Next.js runtime and must be awaited\r\n    const cookieStore = await cookies();\r\n    token = cookieStore.get(TOKEN_COOKIE)?.value;\r\n  } catch {\r\n    // Fallback dla Pages Router (req.cookies)\r\n    token = req?.cookies?.[TOKEN_COOKIE];\r\n  }\r\n\r\n  if (!token) return null;\r\n\r\n  const payload = verifyAuthToken(token);\r\n  if (!payload) return null;\r\n\r\n  return prisma.user.findUnique({\r\n    where: { id: payload.userId },\r\n  });\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAEA;AACA;;;AAEO,eAAe,mBAAmB,OAAoB;IAC3D,MAAM,cAAc,IAAA,8IAAsB,EAAC,QAAQ,OAAO,CAAC,GAAG,CAAC;IAC/D,MAAM,cAAc,IAAA,2IAAmB,EAAC;IACxC,MAAM,QAAQ,eAAe;IAE7B,IAAI,CAAC,OAAO,OAAO;IACnB,MAAM,UAAU,IAAA,uIAAe,EAAC;IAChC,IAAI,CAAC,SAAS,OAAO;IAErB,OAAO,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QAC5B,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;IAC9B;AACF;AAEO,eAAe,aAAa,OAAoB;IACrD,MAAM,OAAO,MAAM,mBAAmB;IACtC,IAAI,CAAC,QAAQ,KAAK,IAAI,KAAK,SAAS;QAClC,OAAO;IACT;IACA,OAAO;AACT;AAGO,eAAe,0BAA0B,GAAS;IACvD,IAAI;IAEJ,IAAI;QACF,8BAA8B;QAC9B,MAAM,EAAE,OAAO,EAAE,GAAG;QACpB,mEAAmE;QACnE,MAAM,cAAc,MAAM;QAC1B,QAAQ,YAAY,GAAG,CAAC,oIAAY,GAAG;IACzC,EAAE,OAAM;QACN,0CAA0C;QAC1C,QAAQ,KAAK,SAAS,CAAC,oIAAY,CAAC;IACtC;IAEA,IAAI,CAAC,OAAO,OAAO;IAEnB,MAAM,UAAU,IAAA,uIAAe,EAAC;IAChC,IAAI,CAAC,SAAS,OAAO;IAErB,OAAO,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QAC5B,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;IAC9B;AACF","debugId":null}},
    {"offset": {"line": 254, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Szymon/Desktop/bezpiesniowy/src/app/api/admin/upload/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport path from \"path\";\r\nimport { promises as fs } from \"fs\";\r\nimport * as mm from \"music-metadata\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { requireAdmin } from \"@/lib/server-auth\";\r\n\r\nexport const runtime = \"nodejs\";\r\n\r\nexport async function POST(request: NextRequest) {\r\n  const admin = await requireAdmin(request);\r\n  if (!admin) {\r\n    return NextResponse.json({ message: \"Brak dostƒôpu\" }, { status: 401 });\r\n  }\r\n\r\n  const formData = await request.formData();\r\n  const file = formData.get(\"file\");\r\n\r\n  if (!(file instanceof File)) {\r\n    return NextResponse.json({ message: \"Plik MP3 jest wymagany\" }, { status: 400 });\r\n  }\r\n\r\n  const titleInput = formData.get(\"title\")?.toString().trim();\r\n  const artistInput = formData.get(\"artist\")?.toString().trim();\r\n  const albumInput = formData.get(\"album\")?.toString().trim();\r\n  const yearInput = formData.get(\"year\")?.toString().trim();\r\n  const genreInput = formData.get(\"genre\")?.toString().trim();\r\n\r\n  const buffer = Buffer.from(await file.arrayBuffer());\r\n  const uploadDir = path.join(process.cwd(), \"public\", \"audio\");\r\n  await fs.mkdir(uploadDir, { recursive: true });\r\n\r\n  const fileName = buildFileName(file.name);\r\n  const filePath = path.join(uploadDir, fileName);\r\n\r\n  const metadata = await readMetadata(buffer, file.type);\r\n\r\n  await fs.writeFile(filePath, buffer);\r\n\r\n  const song = await prisma.song.create({\r\n    data: {\r\n      title: titleInput || metadata.title || \"Nieznany tytu≈Ç\",\r\n      artist: artistInput || metadata.artist || \"Nieznany wykonawca\",\r\n      album: albumInput || metadata.album,\r\n  // Only use the year provided in the upload form. Do not fall back to metadata.year.\r\n  year: yearInput ? Number.parseInt(yearInput, 10) || null : null,\r\n      genre: genreInput || metadata.genre,\r\n      durationSeconds: metadata.durationSeconds,\r\n      fileName,\r\n    },\r\n  });\r\n\r\n  return NextResponse.json(\r\n    {\r\n      message: \"Piosenka zosta≈Ça dodana\",\r\n      song: {\r\n        id: song.id,\r\n        title: song.title,\r\n        artist: song.artist,\r\n        fileName: song.fileName,\r\n      },\r\n    },\r\n    { status: 201 },\r\n  );\r\n}\r\n\r\nfunction buildFileName(originalName: string): string {\r\n  const timestamp = Date.now();\r\n  const base = originalName\r\n    .toLowerCase()\r\n    .replace(/\\s+/g, \"-\")\r\n    .replace(/[^a-z0-9-.]/g, \"\");\r\n  return `${timestamp}-${base || \"audio\"}`;\r\n}\r\n\r\nasync function readMetadata(buffer: Buffer, mimeType: string) {\r\n  try {\r\n    const metadata = await mm.parseBuffer(buffer, mimeType);\r\n    return {\r\n      title: metadata.common.title ?? null,\r\n      artist: metadata.common.artist ?? null,\r\n      album: metadata.common.album ?? null,\r\n      genre: metadata.common.genre?.[0] ?? null,\r\n      year: metadata.common.year ?? null,\r\n      durationSeconds: metadata.format.duration ?? null,\r\n    };\r\n  } catch (error) {\r\n    console.warn(\"Nie uda≈Ço siƒô odczytaƒá metadanych audio\", error);\r\n    return {\r\n      title: null,\r\n      artist: null,\r\n      album: null,\r\n      genre: null,\r\n      year: null,\r\n      durationSeconds: null,\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEO,MAAM,UAAU;AAEhB,eAAe,KAAK,OAAoB;IAC7C,MAAM,QAAQ,MAAM,IAAA,8IAAY,EAAC;IACjC,IAAI,CAAC,OAAO;QACV,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAe,GAAG;YAAE,QAAQ;QAAI;IACtE;IAEA,MAAM,WAAW,MAAM,QAAQ,QAAQ;IACvC,MAAM,OAAO,SAAS,GAAG,CAAC;IAE1B,IAAI,CAAC,CAAC,gBAAgB,IAAI,GAAG;QAC3B,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAyB,GAAG;YAAE,QAAQ;QAAI;IAChF;IAEA,MAAM,aAAa,SAAS,GAAG,CAAC,UAAU,WAAW;IACrD,MAAM,cAAc,SAAS,GAAG,CAAC,WAAW,WAAW;IACvD,MAAM,aAAa,SAAS,GAAG,CAAC,UAAU,WAAW;IACrD,MAAM,YAAY,SAAS,GAAG,CAAC,SAAS,WAAW;IACnD,MAAM,aAAa,SAAS,GAAG,CAAC,UAAU,WAAW;IAErD,MAAM,SAAS,OAAO,IAAI,CAAC,MAAM,KAAK,WAAW;IACjD,MAAM,YAAY,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,UAAU;IACrD,MAAM,yGAAE,CAAC,KAAK,CAAC,WAAW;QAAE,WAAW;IAAK;IAE5C,MAAM,WAAW,cAAc,KAAK,IAAI;IACxC,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,WAAW;IAEtC,MAAM,WAAW,MAAM,aAAa,QAAQ,KAAK,IAAI;IAErD,MAAM,yGAAE,CAAC,SAAS,CAAC,UAAU;IAE7B,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QACpC,MAAM;YACJ,OAAO,cAAc,SAAS,KAAK,IAAI;YACvC,QAAQ,eAAe,SAAS,MAAM,IAAI;YAC1C,OAAO,cAAc,SAAS,KAAK;YACvC,oFAAoF;YACpF,MAAM,YAAY,OAAO,QAAQ,CAAC,WAAW,OAAO,OAAO;YACvD,OAAO,cAAc,SAAS,KAAK;YACnC,iBAAiB,SAAS,eAAe;YACzC;QACF;IACF;IAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;QACE,SAAS;QACT,MAAM;YACJ,IAAI,KAAK,EAAE;YACX,OAAO,KAAK,KAAK;YACjB,QAAQ,KAAK,MAAM;YACnB,UAAU,KAAK,QAAQ;QACzB;IACF,GACA;QAAE,QAAQ;IAAI;AAElB;AAEA,SAAS,cAAc,YAAoB;IACzC,MAAM,YAAY,KAAK,GAAG;IAC1B,MAAM,OAAO,aACV,WAAW,GACX,OAAO,CAAC,QAAQ,KAChB,OAAO,CAAC,gBAAgB;IAC3B,OAAO,GAAG,UAAU,CAAC,EAAE,QAAQ,SAAS;AAC1C;AAEA,eAAe,aAAa,MAAc,EAAE,QAAgB;IAC1D,IAAI;QACF,MAAM,WAAW,MAAM,iLAAc,CAAC,QAAQ;QAC9C,OAAO;YACL,OAAO,SAAS,MAAM,CAAC,KAAK,IAAI;YAChC,QAAQ,SAAS,MAAM,CAAC,MAAM,IAAI;YAClC,OAAO,SAAS,MAAM,CAAC,KAAK,IAAI;YAChC,OAAO,SAAS,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,IAAI;YACrC,MAAM,SAAS,MAAM,CAAC,IAAI,IAAI;YAC9B,iBAAiB,SAAS,MAAM,CAAC,QAAQ,IAAI;QAC/C;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,IAAI,CAAC,2CAA2C;QACxD,OAAO;YACL,OAAO;YACP,QAAQ;YACR,OAAO;YACP,OAAO;YACP,MAAM;YACN,iBAAiB;QACnB;IACF;AACF","debugId":null}}]
}